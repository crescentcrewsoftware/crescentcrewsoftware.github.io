<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple 3D Football Game</title>
  <style>
    body { margin: 0; background: #0a3d0a; }
    #info { position: absolute; top: 10px; left: 10px; color: #fff; font-family: Arial; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; z-index: 2; }
    canvas { display: block; }
    #resetBtn { position: absolute; top: 10px; right: 10px; z-index: 2; padding: 8px 16px; font-size: 16px; }
  </style>
</head>
<body>
<div id="info">
  <b>Simple 3D Football Game</b><br>
  Controls: Arrow keys/WASD to move, Space to kick, P to pass<br>
  <span id="score">Score: 0 - 0</span>
</div>
<button id="resetBtn">Reset</button>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
// --- Basic Football Game ---
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Pitch layout
let pitch = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 60),
  new THREE.MeshLambertMaterial({color: 0x228B22})
);
pitch.rotation.x = -Math.PI/2;
scene.add(pitch);

// Pitch Markings
function addPitchMarkings() {
  const markings = new THREE.Group();
  const lineMat = new THREE.MeshBasicMaterial({color:0xffffff});
  // Center circle
  let circle = new THREE.RingGeometry(9.5, 10, 64);
  let circleMesh = new THREE.Mesh(circle, lineMat);
  circleMesh.rotation.x = -Math.PI/2;
  markings.add(circleMesh);
  // Halfway line
  let halfLine = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 60), lineMat);
  halfLine.position.x = 0;
  halfLine.rotation.x = -Math.PI/2;
  markings.add(halfLine);
  // Penalty boxes
  function penaltyBox(x) {
    let box = new THREE.Mesh(new THREE.PlaneGeometry(18, 40), lineMat);
    box.position.set(x, 0.01, 0);
    box.rotation.x = -Math.PI/2;
    markings.add(box);
  }
  penaltyBox(-41);
  penaltyBox(41);
  // Penalty spots
  function penaltySpot(x) {
    let spot = new THREE.Mesh(new THREE.CircleGeometry(0.7, 16), lineMat);
    spot.position.set(x, 0.02, 0);
    spot.rotation.x = -Math.PI/2;
    markings.add(spot);
  }
  penaltySpot(-36);
  penaltySpot(36);
  // Center spot
  let centerSpot = new THREE.Mesh(new THREE.CircleGeometry(0.7, 16), lineMat);
  centerSpot.position.set(0, 0.02, 0);
  centerSpot.rotation.x = -Math.PI/2;
  markings.add(centerSpot);
  scene.add(markings);
}
addPitchMarkings();

// Scoring Goals
function createGoal(x) {
  let postMat = new THREE.MeshLambertMaterial({color:0xffffff});
  let group = new THREE.Group();
  let post1 = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,8,8), postMat);
  let post2 = post1.clone();
  let bar = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,24,8), postMat);
  post1.position.set(x,4,-12);
  post2.position.set(x,4,12);
  bar.position.set(x,8,0); // Move bar to correct height (top of posts)
  bar.rotation.x = Math.PI/2; // Rotate bar to be horizontal (across z)
  group.add(post1, post2, bar);
  return group;
}
scene.add(createGoal(-50));
scene.add(createGoal(50));

// Ball
let ball = new THREE.Mesh(
  new THREE.SphereGeometry(1.2, 24, 24),
  new THREE.MeshLambertMaterial({color:0xffffff})
);
ball.position.set(0,1.2,0);
scene.add(ball);

// Players (5 per team)
function createPlayer(color, x, z) {
  // More realistic player: head, body, arms, legs
  let group = new THREE.Group();
  // Body
  let bodyMat = new THREE.MeshLambertMaterial({color});
  let body = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 1.1, 2.8, 24), bodyMat);
  body.position.y = 2.2;
  group.add(body);
  // Head
  let headMat = new THREE.MeshLambertMaterial({color: 0xffe0bd});
  let head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 24, 24), headMat);
  head.position.y = 3.7;
  group.add(head);
  // Arms
  let armMat = new THREE.MeshLambertMaterial({color});
  let leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 1.7, 16), armMat);
  leftArm.position.set(-0.95, 2.7, 0);
  leftArm.rotation.z = Math.PI/6;
  group.add(leftArm);
  let rightArm = leftArm.clone();
  rightArm.position.x = 0.95;
  rightArm.rotation.z = -Math.PI/6;
  group.add(rightArm);
  // Legs
  let legMat = new THREE.MeshLambertMaterial({color: 0x222222});
  let leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 1.7, 16), legMat);
  leftLeg.position.set(-0.38, 1, 0);
  group.add(leftLeg);
  let rightLeg = leftLeg.clone();
  rightLeg.position.x = 0.38;
  group.add(rightLeg);
  // Position whole player
  group.position.set(x, 0, z);
  return group;
}

function createTeam(color, xStart, isAI) {
  let team = [];
  // 5-a-side formation: GK, 2 defenders, 2 attackers, 1 midfielder
  let positions = [
    [xStart, 2, 0], // GK
    [xStart + (xStart > 0 ? -7 : 7), 2, -7], // Left Defender
    [xStart + (xStart > 0 ? -7 : 7), 2, 7], // Right Defender
    [xStart + (xStart > 0 ? -18 : 18), 2, -5], // Left Attacker
    [xStart + (xStart > 0 ? -18 : 18), 2, 5], // Right Attacker
    [xStart + (xStart > 0 ? -12 : 12), 2, 0], // Midfielder
  ];
  for (let i = 0; i < positions.length; i++) {
    let p = createPlayer(color, ...positions[i]);
    scene.add(p);
    team.push(p);
  }
  return team;
}
let team1 = createTeam(0x0000ff, -15, false); // Blue (user)
let team2 = createTeam(0xff0000, 15, true); // Red (AI)

// Lighting
let light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(30,60,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x888888));

// Camera
camera.position.set(-70, 45, 0); // Move further back and higher for a wider view
camera.lookAt(0, 0, 0);

// Game state
let ballVel = {x:0, y:0, z:0};
let keys = {};
let score = [0,0];
let lastGoal = 0;

// AI Difficulty Settings
let aiDifficulty = 1; // 1=easy, 2=medium, 3=hard
function setAIDifficulty(level) {
  aiDifficulty = level;
}
// Settings UI
const settingsDiv = document.createElement('div');
settingsDiv.style.position = 'absolute';
settingsDiv.style.bottom = '10px';
settingsDiv.style.left = '10px';
settingsDiv.style.background = 'rgba(0,0,0,0.7)';
settingsDiv.style.color = '#fff';
settingsDiv.style.padding = '12px';
settingsDiv.style.borderRadius = '10px';
settingsDiv.style.zIndex = 10;
settingsDiv.innerHTML = `
  <b>Settings</b><br>
  Blue Kit: <input type="color" id="kit1" value="#0000ff"> &nbsp; Red Kit: <input type="color" id="kit2" value="#ff0000"><br>
  Music: <input type="checkbox" id="musicToggle" checked><br>
  AI Difficulty: <select id="aiDiff">
    <option value="1">Easy</option>
    <option value="2">Medium</option>
    <option value="3">Hard</option>
  </select>
`;
document.body.appendChild(settingsDiv);

document.getElementById('aiDiff').onchange = e => setAIDifficulty(Number(e.target.value));
document.getElementById('musicToggle').onchange = e => {
  if(e.target.checked) music.play(); else music.pause();
};
document.getElementById('kit1').oninput = e => {
  for(let p of team1) p.material.color.set(e.target.value);
  keeper1.material.color.set(e.target.value);
};
document.getElementById('kit2').oninput = e => {
  for(let p of team2) p.material.color.set(e.target.value);
  keeper2.material.color.set(e.target.value);
};

// Music
let music = new Audio('https://cdn.pixabay.com/audio/2022/10/16/audio_12b6b6b6b6.mp3');
music.loop = true;
music.volume = 0.3;
music.play();

// Controls
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Add Keepers
function createKeeper(color, x, z) {
  let mat = new THREE.MeshLambertMaterial({color});
  let body = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,4.5,14), mat);
  body.position.set(x,2.25,z);
  return body;
}
let keeper1 = createKeeper(0x0000ff, -47, 0); // Blue keeper
let keeper2 = createKeeper(0xff0000, 47, 0); // Red keeper
scene.add(keeper1, keeper2);

function resetPositions() {
  let t1 = [[-15,2,0],[-15,2,-10],[-15,2,10],[-7,2,-5],[-7,2,5]];
  let t2 = [[15,2,0],[15,2,-10],[15,2,10],[7,2,-5],[7,2,5]];
  for(let i=0;i<5;i++){
    team1[i].position.set(...t1[i]);
    team2[i].position.set(...t2[i]);
  }
  ball.position.set(0,1.2,0);
  ballVel = {x:0, y:0, z:0};
}

document.getElementById('resetBtn').onclick = () => {
  score = [0,0];
  document.getElementById('score').textContent = `Score: ${score[0]} - ${score[1]}`;
  resetPositions();
};

function movePlayer(player, forward, right) {
  let speed = 0.7;
  player.position.x += forward * speed;
  player.position.z += right * speed;
  // Stay on pitch
  player.position.x = Math.max(-48, Math.min(48, player.position.x));
  player.position.z = Math.max(-28, Math.min(28, player.position.z));
}

function dist(a, b) {
  return Math.sqrt((a.x-b.x)**2 + (a.z-b.z)**2);
}

function animate() {
  // User controls for first player of team1
  let f=0, r=0;
  if(keys['arrowup']||keys['w']) f=1;
  if(keys['arrowdown']||keys['s']) f=-1;
  if(keys['arrowleft']||keys['a']) r=-1;
  if(keys['arrowright']||keys['d']) r=1;
  movePlayer(team1[0], f * 0.6, r * 0.6); // User
  // Teammate AI for other blue players
  for(let i=1;i<team1.length;i++){
    let p = team1[i];
    // If ball is closer to this teammate than to user, move toward ball
    let dToBall = dist(p.position, ball.position);
    let dUserToBall = dist(team1[0].position, ball.position);
    let aiSpeed = 0.32 + 0.18*aiDifficulty; // Increased AI speed for both teams
    if (dToBall < dUserToBall - 1) {
      // Try to intercept ball
      let dx = ball.position.x - p.position.x;
      let dz = ball.position.z - p.position.z;
      let mag = Math.sqrt(dx*dx+dz*dz);
      if (mag > 2) {
        p.position.x += dx/mag*aiSpeed;
        p.position.z += dz/mag*aiSpeed;
      }
    } else {
      // Otherwise, spread out and support
      let homeX = -15 + (i%2===0 ? 8 : 0);
      let homeZ = (i-2)*7;
      p.position.x += (homeX - p.position.x)*0.01;
      p.position.z += (homeZ - p.position.z)*0.01;
    }
  }
  // Dribble: if user is close to ball, keep ball in front while moving
  if (dist(team1[0].position, ball.position) < 3 && (f !== 0 || r !== 0)) {
    // Place ball just ahead of player
    let angle = Math.atan2(r, f);
    let dribbleDist = 2.2;
    ball.position.x = team1[0].position.x + Math.sin(angle) * dribbleDist;
    ball.position.z = team1[0].position.z + Math.cos(angle) * dribbleDist;
    // Keep ball on ground while dribbling
    ball.position.y = 1.2;
    // Slow ball velocity to avoid runaway
    ballVel.x *= 0.5;
    ballVel.z *= 0.5;
  }
  // Kick for user
  if((keys[' ']||keys['space']) && dist(team1[0].position, ball.position)<3) {
    let dx = ball.position.x - team1[0].position.x;
    let dz = ball.position.z - team1[0].position.z;
    let mag = Math.sqrt(dx*dx+dz*dz);
    ballVel.x = dx/mag*1.7; // Reduce kick power
    ballVel.z = dz/mag*1.7;
    ballVel.y = 0.5;
  }
  // Pass for user
  if((keys['p']||keys['P']) && dist(team1[0].position, ball.position)<3) {
    // Find nearest teammate (not self)
    let minDist = 999, passTo = null;
    for(let i=1;i<team1.length;i++){
      let d = dist(team1[0].position, team1[i].position);
      if(d<minDist) { minDist = d; passTo = team1[i]; }
    }
    if(passTo) {
      let dx = passTo.position.x - team1[0].position.x;
      let dz = passTo.position.z - team1[0].position.z;
      let mag = Math.sqrt(dx*dx+dz*dz);
      ballVel.x = dx/mag*1.3; // Reduce pass power
      ballVel.z = dz/mag*1.3;
      ballVel.y = 0.2;
    }
  }
  // AI for team2 (now 5 players)
  for(let i=1;i<team2.length;i++){
    let p = team2[i];
    let dx = ball.position.x - p.position.x;
    let dz = ball.position.z - p.position.z;
    let mag = Math.sqrt(dx*dx+dz*dz);
    let aiSpeed = 0.32 + 0.18*aiDifficulty; // Increased AI speed for both teams
    // Defenders and midfielders: hold formation unless ball is close
    if (i <= 2) { // Defenders
      let homeX = 15 + (i%2===0 ? -5 : 5);
      let homeZ = [-7, 7][i-1];
      if (mag < 8) {
        p.position.x += dx/mag*aiSpeed;
        p.position.z += dz/mag*aiSpeed;
      } else {
        p.position.x += (homeX - p.position.x)*0.01;
        p.position.z += (homeZ - p.position.z)*0.01;
      }
    } else if (i === 3) { // Midfielder
      let homeX = 0;
      let homeZ = 0;
      if (mag < 8) {
        p.position.x += dx/mag*aiSpeed;
        p.position.z += dz/mag*aiSpeed;
      } else {
        p.position.x += (homeX - p.position.x)*0.01;
        p.position.z += (homeZ - p.position.z)*0.01;
      }
    } else { // Attackers
      let homeX = -10;
      let homeZ = [-5, 5][i-4];
      if (mag < 12) {
        p.position.x += dx/mag*aiSpeed;
        p.position.z += dz/mag*aiSpeed;
      } else {
        p.position.x += (homeX - p.position.x)*0.01;
        p.position.z += (homeZ - p.position.z)*0.01;
      }
    }
    // AI kick
    if(mag<3 && Math.abs(ball.position.x)>0.1) {
      ballVel.x = dx/mag*1.7;
      ballVel.z = dz/mag*1.7;
      if (ball.position.y <= 1.21) {
        ballVel.y = 0.5;
      }
    }
  }
  // Keeper AI
  keeperAI(keeper1, true);
  keeperAI(keeper2, false);
  // Ball physics
  ball.position.x += ballVel.x * 0.7; // Slow ball movement
  ball.position.y += ballVel.y * 0.7;
  ball.position.z += ballVel.z * 0.7;
  ballVel.y -= 0.18; // Slightly less gravity for slower pace
  ballVel.x *= 0.985; // Less friction for slower decay
  ballVel.z *= 0.985;
  if(ball.position.y<1.2) { ball.position.y=1.2; ballVel.y*=-0.4; }
  // Ball stays on pitch
  let throwIn = false;
  let goalKick = false;
  if (ball.position.x <= -49) {
    if (Math.abs(ball.position.z) < 12 && ball.position.y < 4) {
      // It's a goal (handled below)
    } else {
      // Out at goal line, goal kick
      ball.position.x = -47;
      ball.position.z = Math.max(-28, Math.min(28, ball.position.z));
      goalKick = true;
    }
  } else if (ball.position.x >= 49) {
    if (Math.abs(ball.position.z) < 12 && ball.position.y < 4) {
      // It's a goal (handled below)
    } else {
      // Out at goal line, goal kick
      ball.position.x = 47;
      ball.position.z = Math.max(-28, Math.min(28, ball.position.z));
      goalKick = true;
    }
  }
  if (ball.position.z <= -29) {
    ball.position.z = -28.5;
    throwIn = true;
  } else if (ball.position.z >= 29) {
    ball.position.z = 28.5;
    throwIn = true;
  }
  if (throwIn) {
    // Stop ball and place at sideline, give to nearest user player
    ballVel = {x:0, y:0, z:0};
    ball.position.y = 2.5;
    // Find nearest user player
    let minDist = 999, nearest = null;
    for (let p of team1) {
      let d = dist(ball.position, p.position);
      if (d < minDist) { minDist = d; nearest = p; }
    }
    // Move nearest player to ball and "throw in"
    if (nearest) {
      nearest.position.x = ball.position.x + (ball.position.x < 0 ? 2 : -2);
      nearest.position.z = ball.position.z;
      setTimeout(() => {
        ballVel.x = (ball.position.x < 0 ? 1.5 : -1.5);
        ballVel.y = 0.5;
        ballVel.z = 0;
        ball.position.y = 2.5;
      }, 400);
    }
  }
  if (goalKick) {
    // Stop ball and place at goal area, give to user's keeper if left, AI keeper if right
    ballVel = {x:0, y:0, z:0};
    ball.position.y = 1.5;
    if (ball.position.x < 0) {
      // User's goal kick
      keeper1.position.x = -47;
      keeper1.position.z = ball.position.z;
      setTimeout(() => {
        ballVel.x = 2.5;
        ballVel.y = 0.5;
        ballVel.z = 0;
      }, 400);
    } else {
      // AI's goal kick
      keeper2.position.x = 47;
      keeper2.position.z = ball.position.z;
      setTimeout(() => {
        ballVel.x = -2.5;
        ballVel.y = 0.5;
        ballVel.z = 0;
      }, 400);
    }
  }
  // Goal detection
  if(ball.position.x<-49 && Math.abs(ball.position.z)<12 && ball.position.y<4 && lastGoal!=1) {
    score[1]++;
    document.getElementById('score').textContent = `Score: ${score[0]} - ${score[1]}`;
    lastGoal=1; setTimeout(resetPositions, 1000);
  } else if(ball.position.x>49 && Math.abs(ball.position.z)<12 && ball.position.y<4 && lastGoal!=2) {
    score[0]++;
    document.getElementById('score').textContent = `Score: ${score[0]} - ${score[1]}`;
    lastGoal=2; setTimeout(resetPositions, 1000);
  } else if(Math.abs(ball.position.x)<48) {
    lastGoal=0;
  }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function keeperAI(keeper, isLeft) {
  // Track ball only in z, stay near goal line
  let targetZ = Math.max(-10, Math.min(10, ball.position.z));
  keeper.position.z += (targetZ - keeper.position.z) * 0.15;
  keeper.position.x = isLeft ? -47 : 47;
  // Try to block if ball is close
  let d = dist(keeper.position, ball.position);
  if(d<3 && Math.abs(ball.position.x - keeper.position.x)<2) {
    ballVel.x *= -0.7;
    ballVel.z += (Math.random()-0.5)*1.2;
    ballVel.y = 0.5;
  }
}

animate();

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
