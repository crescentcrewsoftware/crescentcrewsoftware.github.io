<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Rugby Game</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body { background: #e0f7fa; }
        #game-container { width: 100vw; height: 90vh; margin: 0 auto; display: block; }
        h1 { text-align: center; color: #2e4694; margin-top: 20px; font-size: 3em; }
        .controls { text-align: center; margin: 20px; }
        .controls button { font-size: 1.2em; padding: 10px 20px; margin: 0 10px; background: #ee95a1; color: #2e4694; border: none; border-radius: 6px; cursor: pointer; }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <h1>3D Rugby Game</h1>
    <div class="controls">
        <button onclick="kickBall()">Kick Ball</button>
        <button onclick="resetGame()">Reset</button>
    </div>
    <div id="game-container"></div>
    <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7ec850);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 30, 60);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight * 0.9);
    document.getElementById('game-container').appendChild(renderer.domElement);

    // Orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // Rugby pitch
    const pitchGeometry = new THREE.PlaneGeometry(80, 40);
    const pitchMaterial = new THREE.MeshLambertMaterial({ color: 0x388e3c });
    const pitch = new THREE.Mesh(pitchGeometry, pitchMaterial);
    pitch.rotation.x = -Math.PI / 2;
    scene.add(pitch);

    // Pitch lines
    function addLine(x, z1, z2) {
        const lineGeometry = new THREE.BoxGeometry(0.5, 0.1, Math.abs(z2-z1));
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.position.set(x, 0.05, (z1+z2)/2);
        scene.add(line);
    }
    addLine(-40, -20, 20); // left try line
    addLine(40, -20, 20); // right try line
    addLine(0, -20, 20); // halfway
    addLine(-20, -20, 20); // 22m
    addLine(20, -20, 20); // 22m

    // Rugby posts
    function addPosts(x) {
        const postMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const post1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 6), postMaterial);
        post1.position.set(x, 3, -18);
        scene.add(post1);
        const post2 = post1.clone();
        post2.position.set(x, 3, 18);
        scene.add(post2);
        const crossbar = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 36), postMaterial);
        crossbar.position.set(x, 6, 0);
        scene.add(crossbar);
    }
    addPosts(-40); // left
    addPosts(40); // right

    // Ball
    const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
    const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xfbc02d });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    ball.position.set(0, 1, 0);
    scene.add(ball);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(0, 50, 50);
    scene.add(directionalLight);

    // Players (simple cylinders)
    function addPlayer(x, z, color) {
        const playerGeometry = new THREE.CylinderGeometry(0.8, 0.8, 3, 16);
        const playerMaterial = new THREE.MeshPhongMaterial({ color });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(x, 1.5, z);
        scene.add(player);
        return player;
    }
    let players = [];
    for(let i=-30; i<=30; i+=15) {
        players.push(addPlayer(i, -10, 0x1976d2)); // blue team
        players.push(addPlayer(i, 10, 0xd81b60)); // pink team
    }

    // Ball physics (improved rugby ball motion)
    let ballVelocity = { x: 0, y: 0, z: 0 };
    let isKicked = false;
    let kickPower = 8;
    let kickAngle = 0;
    let isDragging = false;
    let dragStart = null;
    let goalScored = false;

    // Mouse controls for kick direction/power
    renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        dragStart = { x: e.clientX, y: e.clientY };
    });
    renderer.domElement.addEventListener('mouseup', (e) => {
        if (isDragging && !isKicked) {
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;
            kickAngle = dx * 0.02;
            kickPower = Math.min(16, Math.max(4, 8 + dy * -0.05));
            ballVelocity = {
                x: Math.sin(kickAngle) * kickPower,
                y: kickPower * 0.7,
                z: Math.cos(kickAngle) * kickPower
            };
            isKicked = true;
            goalScored = false;
        }
        isDragging = false;
    });

    function kickBall() {
        if (!isKicked) {
            ballVelocity = { x: 2, y: 6, z: 8 };
            isKicked = true;
            goalScored = false;
        }
    }
    function resetGame() {
        ball.position.set(0, 1, 0);
        ballVelocity = { x: 0, y: 0, z: 0 };
        isKicked = false;
        goalScored = false;
        camera.position.set(0, 30, 60);
        controls.target.set(0, 0, 0);
        controls.update();
    }

    // Animate
    function animate() {
        requestAnimationFrame(animate);
        if (isKicked) {
            // Ball physics with damping and spin
            ball.position.x += ballVelocity.x * 0.1;
            ball.position.y += ballVelocity.y * 0.1;
            ball.position.z += ballVelocity.z * 0.1;
            ballVelocity.y -= 0.3; // gravity
            ballVelocity.x *= 0.99; // damping
            ballVelocity.z *= 0.99;
            ball.rotation.z += 0.2; // spin
            // Boundaries
            ball.position.x = Math.max(-39, Math.min(39, ball.position.x));
            ball.position.z = Math.max(-19, Math.min(19, ball.position.z));
            // Ground collision
            if (ball.position.y < 1) {
                ball.position.y = 1;
                ballVelocity = { x: 0, y: 0, z: 0 };
                isKicked = false;
            }
            // Goal detection (between posts)
            if (!goalScored && (ball.position.x < -39.5 || ball.position.x > 39.5) && ball.position.y > 3 && Math.abs(ball.position.z) < 18) {
                goalScored = true;
                setTimeout(() => {
                    alert('Goal scored!');
                }, 100);
            }
            // Camera follow
            camera.position.lerp(new THREE.Vector3(ball.position.x, ball.position.y + 20, ball.position.z + 40), 0.05);
            controls.target.lerp(ball.position, 0.05);
            controls.update();
        }
        renderer.render(scene, camera);
    }
    animate();
    </script>
    <div style="text-align:center;margin-top:20px;">
        <a href="womens-rugby-world-cup-2025.html" style="font-size:1.2em;color:#d81b60;text-decoration:underline;">&#8592; Back to Main Page</a>
    </div>
</body>
</html>
``` 
